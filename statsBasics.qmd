# Statistical Notation

## Sums

\begin{equation}
\begin{split}
\sum_{i=1}^{3}{X_i} &= X_1 + X_2 + X_3\\
\end{split}
\end{equation}



Example:

The equation

\begin{equation}
\begin{split}
\hat{p} &= \frac{\sum\limits_N{Cr(r-1)}}{\sum\limits_N{Cr(s-1)}}\\
\end{split}
\end{equation}

would be more clearly written as

\begin{equation}
\begin{split}
\hat{p} &= \frac{\sum\limits_{i=1}^N{C_ir_i(r_i-1)}}{\sum\limits_{i=1}^N{C_ir_i(s_i-1)}}\\
\end{split}
\end{equation}

## Products

\begin{equation}
\begin{split}
\prod_{i=1}^{3}{X_i} &= X_1 \times X_2 \times X_3\\
\end{split}
\end{equation}

## Likelihood

*Based in part on my class notes from the 1988 UCLA Biomathematics 207 A course "Theoretical Genetic Modeling" taught by Dr. Susan Hodge.* 

The likelihood $L(Hypothesis\ H | Data\ D)$, given a specific model, is proportional to $P(D|H)$ with the constant of proportionality being arbitrary.

As such, the likelihood is a function of the hypothesis, not of the data. 

As Etz (2018) states: 

"The likelihood of a hypothesis (H) given some data (D) is the probability of obtaining D given that H is true multiplied by an arbitrary positive constant K: $L(H) = K × P(D|H)$. ... For likelihood, the data are treated as a given, and the hypothesis varies." (Etz, 2018, p. 60)

Etz A. Introduction to the Concept of Likelihood and Its Applications. Advances in Methods and Practices in Psychological Science. SAGE Publications Inc; 2018 Mar 1;1(1):60–69. DOI: <https://doi.org/10.1177/2515245917744314>


## Conditional Probability

1. Definition:

\begin{equation}
\begin{split}
P(A|B) &= \frac{P(A \cap B)}{P(B)}\\
\end{split}
\end{equation}

where $A \cap B$ stands for "A intersect B" or "A AND B".  This conditional probability formula can be illustrated like this:

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Code generated by Claude AI
# Install and load required package
library(VennDiagram)

# Create a Venn diagram for P(A | B)
grid.newpage()

# Draw the Venn diagram
venn.plot <- draw.pairwise.venn(
  area1 = 100,           # Size of circle A
  area2 = 100,           # Size of circle B
  cross.area = 40,       # Intersection A ∩ B
  category = c("A", "B"),
  fill = c("lightblue", "lightcoral"),
  alpha = c(0.5, 0.5),
  lty = "solid",
  cex = 0,
  fontface = "bold",
  cat.cex = 2.5,
  cat.fontface = "bold",
  cat.pos = c(-20, 20),
  cat.dist = c(0.05, 0.05),
  scaled = TRUE,
  print.mode = "raw"
)

# Add title
grid.text("Conditional Probability: P(A | B)", 
          x = 0.5, y = 0.95, 
          gp = gpar(fontsize = 16, fontface = "bold"))

# Add label for intersection
grid.text("A ∩ B", 
          x = 0.5, y = 0.5, 
          gp = gpar(fontsize = 14, fontface = "bold", col = "darkred"))

# Add explanation
grid.text("P(A | B) = P(A ∩ B) / P(B)", 
          x = 0.5, y = 0.08, 
          gp = gpar(fontsize = 14, col = "darkblue"))

grid.text("The probability of A given that B has occurred", 
          x = 0.5, y = 0.03, 
          gp = gpar(fontsize = 11, col = "gray30"))
```


2. Let $S = \bigcup\limits_{i=1}^nA_i$ and $A_i \cap A_j = \emptyset$ for $i \ne j$.  Then $P(B) = \sum\limits_{i=1}^nP(B|A_i)P(A_i)$

where $\emptyset$ stands for the empty set and $\bigcup$ is the union operator. For example, $A_1 \bigcup A_2$ is the union of the elements in the sets $A_1$ and $A_2$. This is the set of elements that are shared in common between $A_1$ and $A_2$. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Generated using Claude AI
# Law of Total Probability Visualization
library(grid)

# Clear the plot
grid.newpage()

# Define the sample space and partitions
n <- 4  # Number of partitions

# Set up viewport
pushViewport(viewport(width = 0.9, height = 0.8))

# Define colors for each partition
colors <- c("lightblue", "lightgreen", "lightyellow", "lightpink")
partition_heights <- c(0.3, 0.25, 0.2, 0.25)  # Heights for each A_i

# Draw the sample space boundary
grid.rect(x = 0.5, y = 0.5, width = 0.8, height = 0.9,
          gp = gpar(lwd = 3, fill = NA))
grid.text("Sample Space S", x = 0.5, y = 0.96, 
          gp = gpar(fontsize = 14, fontface = "bold"))

# Draw partitions A_i
y_start <- 0.05
for (i in 1:n) {
  y_pos <- y_start + sum(partition_heights[1:i]) - partition_heights[i]/2
  
  # Draw partition rectangle (no gap - full height)
  grid.rect(x = 0.5, y = y_pos, 
            width = 0.8, height = partition_heights[i],
            gp = gpar(fill = colors[i], col = "black", lwd = 2))
  
  # Label partition
  grid.text(bquote(A[.(i)]), 
            x = 0.12, y = y_pos,
            gp = gpar(fontsize = 12, fontface = "bold"))
}

# Draw event B as an oval overlapping all partitions
grid.circle(x = 0.65, y = 0.5, r = 0.25,
            gp = gpar(col = "red", lwd = 3, fill = NA))
grid.text("B", x = 0.82, y = 0.5,
          gp = gpar(fontsize = 14, fontface = "bold", col = "red"))

# Draw intersection labels
y_start <- 0.05
for (i in 1:n) {
  y_pos <- y_start + sum(partition_heights[1:i]) - partition_heights[i]/2
  
  # Add B ∩ A_i label (adjust y position for first partition)
  label_y <- ifelse(i == 1, y_pos + 0.10, y_pos)
  grid.text(bquote(B %intersection% A[.(i)]), 
            x = 0.65, y = label_y,
            gp = gpar(fontsize = 10, fontface = "italic", col = "darkred"))
}

popViewport()

# Add title and formula at the bottom
grid.text(expression(paste("P(B) = ", sum(P(B*"|"*A[i])*P(A[i]), i==1, n))),
          x = 0.5, y = 0.08,
          gp = gpar(fontsize = 13, col = "darkblue", fontface = "bold"))

grid.text(expression(paste("where ", A[i] %intersection% A[j] == emptyset, " for ", i != j, 
                          " and ", S == union(A[i], i==1, n))),
          x = 0.5, y = 0.03,
          gp = gpar(fontsize = 10, col = "gray30"))
```


3. $P(A|B) = \frac{P(B|A)P(A)}{P(B)}$

4. Bayes Rule

Let $S = \bigcup\limits_{i=1}^nA_i$ and $A_i \cap A_j = \emptyset$ for $i \ne j$.  Then $P(A_j|B) =\frac{P(B|A_j)P(A_j)}{\sum\limits_{i=1}^nP(B|A_i)P(A_i)}$

5. Intermediate Conditioning

\begin{equation}
\begin{split}
P(A|B) = \sum\limits_{i}P(A|X_i,B)P(X_i|B)\\
\end{split}
\end{equation}

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Intermediate Conditioning Formula Visualization
library(grid)

# Clear the plot
grid.newpage()

# Set up viewport
pushViewport(viewport(width = 0.9, height = 0.85))

# Define colors for partitions
n <- 4  # Number of X_i partitions
colors <- c("lightblue", "lightgreen", "lightyellow", "lightpink")
partition_widths <- c(0.2, 0.25, 0.3, 0.25)  # Widths for each X_i

# Draw event B as an ellipse (the conditioning context)
theta_b <- seq(0, 2*pi, length.out = 100)
a_b <- 0.35  # semi-major axis for B
b_b <- 0.30  # semi-minor axis for B
x_ellipse_b <- 0.45 + a_b * cos(theta_b)
y_ellipse_b <- 0.5 + b_b * sin(theta_b)

grid.polygon(x = x_ellipse_b, y = y_ellipse_b,
             gp = gpar(col = "red", lwd = 4, fill = NA))
grid.text("Event B (Given)", x = 0.45, y = 0.87, 
          gp = gpar(fontsize = 14, fontface = "bold", col = "red"))

# Draw partitions X_i within B (vertical stripes clipped to ellipse)
# Calculate the bounds of B ellipse
b_left <- 0.45 - a_b
b_right <- 0.45 + a_b
b_width <- 2 * a_b

# Adjust partition widths to fill B
partition_widths_adjusted <- partition_widths * (b_width / sum(partition_widths))

x_start <- b_left
for (i in 1:n) {
  x_left <- x_start + sum(partition_widths_adjusted[0:(i-1)])
  x_right <- x_left + partition_widths_adjusted[i]
  
  # For each x position in partition, calculate y bounds on ellipse
  # Create polygon that follows ellipse curve
  x_seq <- seq(x_left, x_right, length.out = 50)
  y_upper <- numeric(50)
  y_lower <- numeric(50)
  
  for (j in 1:50) {
    x_offset <- x_seq[j] - 0.45
    if (abs(x_offset) <= a_b) {
      y_half <- b_b * sqrt(1 - (x_offset/a_b)^2)
      y_upper[j] <- 0.5 + y_half
      y_lower[j] <- 0.5 - y_half
    }
  }
  
  # Draw filled polygon for partition
  x_poly <- c(x_seq, rev(x_seq))
  y_poly <- c(y_upper, rev(y_lower))
  
  grid.polygon(x = x_poly, y = y_poly,
               gp = gpar(fill = colors[i], col = NA))  # No borders
}

# Label partitions below
x_start <- b_left
for (i in 1:n) {
  x_pos <- x_start + sum(partition_widths_adjusted[1:i]) - partition_widths_adjusted[i]/2
  
  grid.text(bquote(X[.(i)]), 
            x = x_pos, y = 0.17,
            gp = gpar(fontsize = 12, fontface = "bold"))
}

# Redraw B ellipse on top for clarity
grid.polygon(x = x_ellipse_b, y = y_ellipse_b,
             gp = gpar(col = "red", lwd = 4, fill = NA))

# Draw event A as an ellipse extending outside B
theta <- seq(0, 2*pi, length.out = 100)
a_val <- 0.30  # semi-major axis
b_val <- 0.25  # semi-minor axis
x_ellipse <- 0.60 + a_val * cos(theta)
y_ellipse <- 0.50 + b_val * sin(theta)

grid.polygon(x = x_ellipse, y = y_ellipse,
             gp = gpar(col = "darkblue", lwd = 3, fill = NA))
grid.text("A", x = 0.92, y = 0.58,
          gp = gpar(fontsize = 14, fontface = "bold", col = "darkblue"))

popViewport()

# Add title and formula
grid.text("Intermediate Conditioning Formula", 
          x = 0.5, y = 0.96,
          gp = gpar(fontsize = 16, fontface = "bold"))

grid.text(expression(paste("P(A|B) = ", sum(P(A*"|"*X[i]*","*B)*P(X[i]*"|"*B), i))),
          x = 0.5, y = 0.07,
          gp = gpar(fontsize = 13, col = "darkblue", fontface = "bold"))


```


6. $P(A|B, C) = \frac{P(B|A,C)P(A|C)}{P(B|C)}$

7. $P(A,B|C) = P(A|B,C)P(B|C)$

8. If $A_i$ are mutually exclusive and exhaustive, then

\begin{equation}
\begin{split}
P(A_j|B, C) = \frac{P(B|A_j,C)P(A_j|C)}{\sum\limits_iP(B|A_i,C)P(A_i|C)}\\
\end{split}
\end{equation}